(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{165:function(n,e,t){"use strict";t.r(e);var a=t(0),s=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"webpack输出管理。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack输出管理。","aria-hidden":"true"}},[n._v("#")]),n._v(" webpack输出管理。")]),n._v(" "),t("p",[n._v("上一章中，对于js管理来说，我们使用webpack打包生成固定名字的JS文件，然后在html中手动引入。然后在生产环境中，js文件数量会非常多，意味着我们需要手动引入大量的js文件，并且当我们的js文件名称更改之后，还要手动修改引入的js文件，这显然是不可取的。"),t("br"),n._v("\n本章我们将介绍，如何处理生产环境中的不同js文件的打包输出和自动引入。")]),n._v(" "),t("h2",{attrs:{id:"预先准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预先准备","aria-hidden":"true"}},[n._v("#")]),n._v(" 预先准备")]),n._v(" "),t("p",[n._v("首先我们初始化一个项目")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("npm init -y\n")])])]),t("p",[n._v("初始化完成后，我们搭建项目结构")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("demo3\n|- dist\n  |- index.html\n|- src\n  |- index.js\n  |- print.js\n|- package.json\n|- webpack.config.js\n")])])]),t("p",[n._v("然后我们安装依赖文件 lodash webpack webpack-cli")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("npm install lodash\nnpm install -D webpack webpack-cli\n")])])]),t("p",[n._v("src/index.js")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import _ from 'lodash'\nimport printMe from './print.js'\n\nfunction component () {\n  var ele = document.createElement('div')\n  var btn = document.createElement('button')\n\n  ele.innerHTML = _.join(['Hello', 'Webpack'], '~')\n  \n  btn.innerHTML = \"Click me and check the console\"\n  btn.onclick = printMe\n\n  ele.appendChlid(btn)\n  return ele\n}\n\ndocument.body.appendChild(component())\n")])])]),t("p",[n._v("src/print.js")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export default function printMe() {\n  console.log('called from printMe')\n}\n")])])]),t("p",[n._v("dist/index.html文件中我们写入")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8">\n    <title>Output Management</title>\n  </head>\n  <body>\n    <script type="text/javascript" src="app.bundle.js"><\/script>\n    <script type="text/javascript" src="print.bundle.js"><\/script>\n  </body>\n</html>\n')])])]),t("p",[n._v("目前，我们还是采用index.html手动引入的方式，可以看到，我们将使用webpack打包生成app.bundle.js和print.bundle.js两个依赖文件。")]),n._v(" "),t("p",[n._v("webpack.config.js写入")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const path = require('path')\n\nmodule.exports = {\n  entry: { // 多个入口\n    app: './src/index.js',\n    print: './src/print.js'\n  },\n  output: {\n    // 每个入口对应的是一个出口文件。多个输出文件，根据name自动生成\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  }\n}\n")])])]),t("p",[n._v("修改package.json的打包命令")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('···\n"scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1",\n    "build": "webpack"\n  },\n···\n')])])]),t("p",[n._v("执行打包语句npm run build可以看到结果。在dist目录中自动打包生成了app.bundle.js文件和print.bunlde.js文件。当我们的js文件改名，或者又新增了js文件时，此时我们只能再手动修改index.html中的"),t("code",[n._v("<srcipt>")]),n._v("标签，很显然这种做法在生产环境下是不可取的。接下来我们就使用webpack提供的HtmlWebpackPlugin插件，来自动生成index.html文件。")]),n._v(" "),t("h2",{attrs:{id:"htmlwebpackplugin插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#htmlwebpackplugin插件","aria-hidden":"true"}},[n._v("#")]),n._v(" HtmlWebpackPlugin插件")]),n._v(" "),t("p",[n._v("该插件的作用是自动管理index.html。简化了HTML文件的创建。"),t("br"),n._v("\n安装 "),t("code",[n._v("npm install html-webpack-plugin")]),t("br"),n._v("\n在webpack.config.js中引入")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("entry: ···\n···\nplugins: [\n  new HtmlWebpackPlugin({ // 会自动生成index.html，并自动引入js依赖\n    title: 'Output Management'\n  })\n],\noutput: ···\n···\n")])])]),t("p",[n._v("删除dist文件夹下的所有文件，执行"),t("code",[n._v("npm run build")]),n._v("可以看到，在dist文件夹中又自动生成了index.html")]),n._v(" "),t("h2",{attrs:{id:"cleanwebpackplugin插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cleanwebpackplugin插件","aria-hidden":"true"}},[n._v("#")]),n._v(" CleanWebpackPlugin插件")]),n._v(" "),t("p",[n._v("之前的操作中，我们每一次build之前都要手动删除dist文件夹中的文件，并没有完全的自动化，webpack中插件早已帮我们考虑到了这一步。引入CleanWebpackPlugin插件，让其自动在build时候，帮我们删除掉dist目录。"),t("br"),n._v("\n安装插件"),t("code",[n._v("npm install -D clean-webpack-plugin")]),n._v("\n配置插件"),t("br"),n._v("\n此时webpack.config.js变成下面这样")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const path = require('path')\nconst HtmlWebpckPlugin = require('html-webpack-plugin')\nconst CleanWebpackPlugin = require('clean-webpack-plugin')\n\nmodule.exports = {\n  entry: { // 多个入口。\n    app: './src/index.js',\n    print: './src/print.js'\n  },\n  plugins: [\n    new CleanWebpackPlugin(['dist']), // 用于在每次构建时，清理dist文件夹\n    new HtmlWebpckPlugin({ // 会自动生成index.html，并自动引入js依赖\n      title: 'Output Management'\n    })\n  ],\n  output: {\n    // 多入口，必须有多输出, 根据name和hash生成，确保每一次生成的JS文件都不一样\n    filename: '[name].[hash].bundle.js', \n    path: path.resolve(__dirname, 'dist')\n  }\n}\n")])])]),t("p",[n._v("运行"),t("code",[n._v("npm run build")]),n._v("可以看到，webpack帮我们自动删除了dist文件，然后才开始构建。")])])}],!1,null,null,null);s.options.__file="2.md";e.default=s.exports}}]);